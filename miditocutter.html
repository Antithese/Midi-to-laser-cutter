<html>
	<body>
		<script src="inc/midi-parser.js"></script>
		<script src="inc/snap.svg-min.js"></script>
		<form>
			<input type="file" name="fileupload" value="fileupload" id="fileupload">
			<label for="fileupload"> Select a file to upload</label>
		</form>
		<script type="text/javascript">
			var noteLetters = ["c", "c#", "d", "d#", "e", "f", "f#", "g", "g#", "a", "a#", "b"]
			var notes = [];
			var scaleModes = {
				major: {
					ionian:  	[2,2,1,2,2,2],
					dorian: 	[2,1,2,2,2,1],
					phyrigian:  [1,2,2,2,1,2],
					lydian:     [2,2,2,1,2,2],
					mixolydian: [2,2,1,2,2,1],
					aeolian:    [2,1,2,2,1,2],
					locrian:    [1,2,2,1,2,2] 
				},
				harmonic_minor: {
					harmminor: 		[2,1,2,2,1,3],
					locriansharpsix:[1,2,2,1,3,1], 
					ionianaug:     	[2,2,1,3,1,2], 
					romanian: 		[2,1,3,1,2,1],
					phrygiandom:   	[1,3,1,2,1,2],
					lydiansharptwo: [3,1,2,1,2,2],
					ultralocrian:   [1,2,1,2,2,1]
				},
				melodic_minor: {
					jazz_minor: 		[2,1,2,2,2,2],
					dorianflatnine: 	[1,2,2,2,2,1],
					lydianaug: 			[2,2,2,2,1,2],
					lydiandom: 			[2,2,2,1,2,1],
					mixolydianflatsix: 	[2,2,1,2,1,2],
					semilocrian: 		[2,1,2,1,2,2],
					superlocrian: 		[1,2,1,2,2,2]
				}
			}

			function generateScale(root, scale, mode) {
				var result = [];
				var gaps = scaleModes[scale][mode];
				if (gaps === undefined) return undefined;
				result.push(root);
				var lastNoteNum = noteLetters.indexOf(root);
				for (var i=0; i<gaps.length; i++) {
					lastNoteNum += gaps[i];
					result.push(noteLetters[lastNoteNum%12]);
				}

				return result;
			}
			
			function autoCadGenerate(notesAgainstTime, holeDiameter) {
				var cadCommand = '_.circle\n';
				var fileName = 'AutoCAD.scr';
				var fileText = '';
				
				for (var i=0; i<notesAgainstTime.length; i++) {
					var note = notesAgainstTime[i];
					fileText = fileText + cadCommand + note.x + ',' + note.y + '\n' + holeDiameter + '\n';
				}
				
				var element = document.createElement('a');
				element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(fileText));
				element.setAttribute('download', fileName);

				element.style.display = 'none';
				document.body.appendChild(element);

				element.click();

				document.body.removeChild(element);
			}

			function svgGenerate(notesAgainstTime, holeDiameter) {
				function mm(mmtopix) {return mmtopix*3.7795275590551};

				var svgelement = document.createElement('svg');
				svgelement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
				svgelement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
				svgelement.setAttribute('version', '1.1');

				var drawing = Snap(document.getElementById('svg'));
				for (var i=0; i<notesAgainstTime.length; i++) {
					var note = notesAgainstTime[i];
					var circle = drawing.circle(mm(note.x), mm(note.y), mm(holeDiameter/2));
					circle.attr({
						fillOpacity: 0,
						stroke: '#000',
						strokewidth: 1
					});				
				}

				drawing.attr({
					style: 'padding: 0; margin: 0;'
				});

				var svg = drawing.toString();
				var filename = "test.svg";

				
				var element = document.createElement('a');
				element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(svg));
				element.setAttribute('download', filename);

				element.style.display = 'none';
				document.body.appendChild(element);

				element.click();

				document.body.removeChild(element);
			}

			for (var num = 0; num < 128; num++) {
				notes.push(noteLetters[num%12] + Math.floor(num/12));
			}
			var events = [];
			var notesAgainstTime = [];

			function processData(midiData) {
				console.log(midiData);
				var scale = generateScale("c", "major", "phyrigian");
				console.log(scale);
				for(var i=0; i<midiData.tracks; i++){
					var currentTick = 0;
					for(var j=0; j<midiData.track[i].event.length; j++) {
						var event = midiData.track[i].event[j];
						currentTick+=event.deltaTime;
						if (event.type == 9){ //note on events
							var noteLetter = noteLetters[(event.data[0]-60)%12];
							var indexOfNote = scale.indexOf(noteLetter);
							var adjustedIndex = indexOfNote + scale.length*(Math.trunc((event.data[0]-60)/12))
							if (indexOfNote != -1) {
								events.push({type: "noteon", tick: currentTick, pitch: adjustedIndex, note: notes[event.data[0]], channel: event.channel, track: i});
							}
						}	
						else if (event.type == 255) { //meta events
							if(event.metaType == 81) { //tempo change events
								events.push({type: "tempochange", tempo: event.data, tick: currentTick});
							}
						}
					}
				}
				events.sort(function (a,b) {return a.tick > b.tick;});

				var timeAtLastTempoChange = 0;
				var ticksAtLastTempoChange = 0;
				var tempo = 500000;
				var ppq = midiData.timeDivision;

				for (var i=0; i<events.length; i++) {
					var event = events[i];

					if (event.type == "tempochange") {
						timeAtLastTempoChange += tempo * (event.tick - ticksAtLastTempoChange) / ppq;
						tempo = event.tempo;
						ticksAtLastTempoChange = event.tick;
						console.log("Tempo changed to " + tempo + " at " + timeAtLastTempoChange);
					}
					if (event.type == "noteon") {
						var rtime = timeAtLastTempoChange + tempo * (event.tick - ticksAtLastTempoChange) / ppq;
						notesAgainstTime.push({time: rtime, pitch: event.pitch, x: 0, y: 0});
					}
				}
				
				var machineTempo = 1000000;
				var xOffset = 4;
				var yOffset = 3;
				
				for (var i=0; i<notesAgainstTime.length; i++) {
					var note = notesAgainstTime[i];
					note.x = (note.time/machineTempo)*xOffset;
					note.y = (note.pitch)*yOffset;
				}
				console.log(notesAgainstTime);
				//autoCadGenerate(notesAgainstTime, .75);
				svgGenerate(notesAgainstTime, .75);
			};
			
			var file = document.getElementById("fileupload");
			MIDIParser.addListener(document.getElementById("fileupload"), processData);
		</script>
	</body>
</html>